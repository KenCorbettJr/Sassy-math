// SASSY MATH

// ref http://compass-style.org/reference/compass/helpers/trig/

@charset "UTF-8"

// Variables
$pi: 3.14159265
$π: $pi
$e: 2.718281828

$rand: random number

@function percent($number)
  @return ($number * .01)

@function exponent($base, $exponent)
  // reset value
  $value: $base
  // positive intergers get multiplied
  @if $exponent > 1
    @for $i from 2 through $exponent
      $value: $value * $base
  // negitive intergers get divided. A number divided by itself is 1
  @if $exponent < 1
    @for $i from 0 through -$exponent
      $value: $value / $base
  // return the last value written
  @return $value
  
@function factorial($number)
  // reset value
  $value: 1
  // positive intergers get multiplied
  @if $number > 0
    @for $i from 1 through $number
      $value: $value * $i

  @return $value
  
  //Implemented with Taylor Series, CORDIC is more elegant but i assume performance is not an issue
  
@function sin($number)
  // iterations
  $n: 7 
  $value: $number
  $odd: 1
  $add: 0
  @if $number < (-$pi/2) or $number > ($pi/2)
    @if $number < 0
      $value: sin($number + $pi)
    @else
      $value: sin($number - $pi)
    $value: -$value
    @return $value
  
  @for $i from 3 through $n
    @if $odd == 1
      $odd: 0
      @if $add == 1
        $value: $value + exponent($value, $i)/factorial($i)
        $add: 0
      @else
        $value: $value - exponent($value, $i)/factorial($i)
        $add: 1
  @return ($value)

@function sinh($number)
  @return ($number)

@function cos($number)
  @return ($number)

@function cosh($number)
  @return ($number)

@function tan($number)
  @return ($number)

@function tanh($number)
  @return ($number)

@function log($number)
  @return ($number)

@function ln($number)
  @return ($number)
  
// Factorials
@function factorial($number)
  $holder: 1
  @for $i from 1 through $number
    $holder: $holder * $i
  @return ($holder)

@function fact($number)
  @return factorial($number)

// Convert between Degrees and Radians
@function deg-to-rad($number)
  @return ($number * ( $pi / 180deg))

@function rad-to-deg($number)
  @return ($number * ( 180deg / $pi ))

// nth Root of a Number
@function n-root($number, $n)
  @if $number < 1
    @return ERROR
    @warn ROOT ERROR
  // If a whole number, generate it quickly
  @for $i from 1 through $number
    @if exponent($i, $n) == $number
      @return $i
  // Else, run through other options
  @for $i from 1 through (($number * 1000) / 2)
    @if round(exponent(($i / 1000), $n) * 100) == round($number * 100)
      @return ($i / 1000)

// Square Roots
@function √($number)
  @return n-root($number, 2)

@function root($number)
  @return n-root($number, 2)
  
@function sqrt($number)
  @return n-root($number, 2)


// TESTS
.foo
  width: √(9)
  width: √(9) * √(9)
  width: deg-to-rad(90deg)
  width: factorial(9)
  -webkit-transform: rotate(rad-to-deg($pi/2))
  width: sin(0)
  width: sin($pi / 16)
  width: sin($pi / 8)
  width: sin($pi / 4)
  width: sin($pi / 2)
  width: sin($pi)
  width: sin(10)
  
